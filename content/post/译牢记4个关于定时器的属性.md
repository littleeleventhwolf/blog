---
title: "[译]牢记4个关于定时器的属性"
date: 2022-05-20T12:19:35+08:00
lastmod: 2022-05-20T12:19:35+08:00
keywords: ["flink"]
categories: ["flink"]
tags: ["flink"]
author: "小十一狼"
---

原文：[4 characteristics of Timers in Apache Flink to keep in mind](https://www.ververica.com/blog/4-characteristics-of-timers-in-apache-flink)

这篇博客讲述Apache Flink中关于使用定时器的一些基础概念和需要考虑的点。在ProcessFunction算子中可以访问流处理应用中基础的构建块：

- 事件（流的元素）
- 状态（容错，一致性，仅在keyed stream上）
- 定时器（事件时间和处理时间，仅在keyed stream上）

开发者可以在ProcessFunction中注册定时器。

关于ProcessFunction更多的信息，建议阅读[Apache Flink官方文档](https://ci.apache.org/projects/flink/flink-docs-stable/dev/stream/operators/process_function.html)获取更多指示和指导。

# Apache Flink的定时器是什么？

定时器是可以让流处理应用能够响应并适应处理时间和事件时间的变化。早前的一篇[博客](https://www.ververica.com/blog/stream-processing-introduction-event-time-apache-flink)讲解了Apache Flink中的一些时间概念以及处理、摄入、事件时间的差异细节。当对事件流使用定时器，`processElement(...)`会逐个事件被调用，传入一个Context对象帮助用户访问事件的时间戳和一个定时器服务TimerService。接下来就可以使用TimerService为将要处理的事件时间或处理时间注册定时器回调处理逻辑。之后，当指定的那个时刻来临时，`onTimer(...)`方法就会被调用。

取决于定时器注册使用的是处理时间或事件时间，`onTimer(...)`回调方法会在不同时刻被调用，比如：

- 当处理时间被用于注册定时器，机器时钟到达定时器的时间戳时，`onTimer(...)`方法会被调用；
- 当事件时间被用于注册定时器，算子水位线到达或超过定时器的时间戳时，`onTimer(...)`方法会被调用。

和`processElement(...)`方法类似，在`onTimer(...)`方法中对状态存取也作用于当前key（即，为其注册定时器的key）。

值得注意的是，`onTimer(...)` 和`processElement(...)`都是同步的，因此这两个方法中对状态的存取和更改是安全的。

# 4个关于定时器的属性

这里我们讨论需要牢记的4个关于定时器的属性：

## 1. 定时器是注册在KeyedStream上的

由于是按key注册并触发定时器，所以在任何使用定时器的算子和函数上，KeyedStream都是一个必须的先决条件。

## 2. 定时器服务会自动去重定时器

定时器服务TimerService自动去掉重复的定时器，只对每个key和时间戳保留至多一个定时器。这意味着当同一个key或时间戳上注册了多个定时器，`onTimer(...)`方法只会被调用一次。

## 3. 定时器会被制作检查点

Flink会把定时器制作成managed state进行Checkpointing。当作业从checkpoint和savepoint恢复时，在恢复前该被触发的定时器会立即触发。

## 4. 定时器可以被删除

从Flink 1.6开始，定时器可以被[暂停和删除](https://ci.apache.org/projects/flink/flink-docs-stable/dev/stream/operators/process_function.html#timer-coalescing)。当Flink版本早于1.5时，可能会遇到Checkpointing性能不佳的问题，因为有许多无法删除和暂停的定时器。

![Apache Flink中4个定时器的属性](/牢记4个关于定时器的属性/4_characterisrics_of_timer.png)

你可以通过以下方式停止处理时间的定时器：

```java
long timestampOfTimerToStop = ...;
ctx.timerService().deleteProcessingTimeTimer(timestampOfTimerToStop);
```

你也可以通过以下方式停止事件时间的定时器：

```java
long timestampOfTimerToStop = ...;
ctx.timerService().deleteEventTimeTimer(timestampOfTimerToStop);
```

注意，如果指定时间戳上没有注册定时器，那么停止定时器无效。
